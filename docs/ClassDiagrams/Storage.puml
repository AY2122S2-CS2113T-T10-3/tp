@startuml
!include Style.puml

skinparam arrowThickness 1.1
'I wasn't able to find a consistent standard for bound elements, so I just picked one
package storage {
    interface Storage <T extends Object> {
        --
        + writeData(object: T, path: String): void
        + loadData(path: String): T
        + createTargetFile(path: String): void

    }

    abstract class JsonStorage <T extends Object> implements Storage {
       --
       + writeData(object: T, path: String): void
       + {abstract} loadData(path: String): T
       + createTargetFile(path: String): void
    }

    abstract class ListStorage <ModHappyT extends Object> extends JsonStorage {
       --
       + {abstract} loadData(path: String): ArrayList<ModHappyT>
    }

    ListStorage ..> JsonStorage : <<bind>>\nT -> ArrayList<ModHappyT>

    class ConfigurationStorage extends JsonStorage {
       --
       + loadData(path: String): Configuration
    }

    ConfigurationStorage ..> JsonStorage : <<bind>>\nT -> Configuration

    class ModuleListStorage extends ListStorage {
       --
       + loadData(path: String): ArrayList<Module>
    }

    ModuleListStorage ..> ListStorage : <<bind>>\nModHappyT -> Module

    class TaskListStorage extends ListStorage {
       --
       + loadData(path: String):ArrayList<Task>
    }

    TaskListStorage ..> ListStorage : <<bind>>\nModHappyT -> Task
}

note top of storage
To avoid clutter, inherited methods
are not displayed in child classes.
end note

Class Main
hide Main circle
hide Main attributes
hide Main methods

Class SaveCommand
hide SaveCommand circle
hide SaveCommand attributes
hide SaveCommand methods

Main--> Storage
SaveCommand --> Storage

@enduml